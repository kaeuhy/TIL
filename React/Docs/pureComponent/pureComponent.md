### 컴포넌트를 순수하게 유지하기

일부 자바스크립트 함수는 순수합니다. 순수 함수는 오직 연산만을 수행합니다.

컴포넌트를 엄격하게 순수 함수로만 작성하면 코드베이스의 규모가 점점 커지더라도 예상밖의 동작이나 당황케하는 버그를 피할 수 있습니다.

이런 효과를 얻기 위해서는 몇 가지 규칙을 따라야 합니다.

</br>
</br>

### 순수성 - 수식으로서의 컴포넌트

함수형 프로그래밍의 세계에서는 순수 함수는 다음과 같은 특징을 지니고 있습니다.

- **자신의 일에만 집중합니다.**
    - 함수가 호출되기 전에 존재했던 어떤 객체나 변수도 변경하지 않습니다.
- **같은 입력, 같은 출력을 합니다.**
    - 같은 입력이 주어졌다면 순수 함수는 항상 같은 결과를 반환합니다.

</br>

다음 코드에서 `double` 은 순수 함수입니다.

```tsx
function double(number) {
	return 2 * number;
}
```

인자로 `3` 을 넘긴다면, 항상 `6` 을 반환합니다.

</br>

React는 이러한 개념을 기반으로 설계되어 여러분이 작성하는 모든 컴포넌트가 순수함수라고 가정합니다.

이러한 가정은 React 컴포넌트에 같은 입력이 주어진다면 늘 같은 JSX를 반환한다는 것을 의미합니다.

```tsx
// App.js
function Recipe({ drinkers }) {
  return (
    <ol>
      <li>Boil {drinkers} cups of water.</li>
      <li>Add {drinkers} spoons of tea and {0.5 * drinkers} spoons of spice.</li>
      <li>Add {0.5 * drinkers} cups of milk to boil and sugar to taste.</li>
    </ol>
  );
}

export default function App() {
  return (
    <section>
      <h1>Spiced Chai Recipe</h1>
      <h2>For two</h2>
      <Recipe drinkers={2} />
      <h2>For a gathering</h2>
      <Recipe drinkers={4} />
    </section>
  );
}
```

`Recipe` 컴포넌트에 `drinkers={2}`  `props` 를 넘기면 항상 `2 cups of water` 를 포함한 JSX를 반환합니다.

`drinkers={4}` `props` 를 넘기면 항상 `4 cups of water` 를 포함한 JSX를 반환합니다.

</br>
</br>

### 사이드 이펙트 - 의도하지(않은) 결과

React의 렌더링 과정은 항상 순수해야 합니다.

컴포넌트는 JSX만 반환해야 하며, 렌더링 이전에 존재했던 어떤 객체나 변수도 변경해서는 안 됩니다.

이러한 것들은 컴포넌트를 순수하지 않게 만듭니다.

</br>

아래 코드는 이러한 규칙을 위반하는 컴포넌트 예시입니다.

```tsx
// App.js
let guest = 0;

function Cup() {
  // 나쁜 지점: 이미 존재했던 변수를 변경하고 있습니다!
  guest = guest + 1;
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup />
      <Cup />
      <Cup />
    </>
  );
}

```

해당 컴포넌트는 컴포넌트 외부에 선언된 `guest` 라는 변수를 읽고 수정하고 있습니다.

이는 해당 컴포넌트를 여러 번 호출할 때마다 서로 다른 JSX를 생성한다는 것을 의미합니다.

게다가 다른 컴포넌트들이 `guest` 변수를 읽는다면, 각각 언제 렌더링 되었는지에 따라 서로 다른 JSX를 생성하여 예측 불가능하게 합니다.

</br>

이러한 문제점은 `guest` 변수를 `Prop` 으로 넘겨 해결할 수 있습니다.

```tsx
function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup guest={1} />
      <Cup guest={2} />
      <Cup guest={3} />
    </>
  );
}
```

이제 컴포넌트가 `guest` `prop` 에만 의존해 JSX를 반환하므로 순수해졌습니다.

</br>

일반적으로 컴포넌트가 특정 순서대로 렌더링될 것이라고 기대하면 안됩니다.

각 컴포넌트는 자기 자신만 생각해야하고 렌더링 도중에 다른 컴포넌트와 영향을 주고 받거나, 의존해서는 안됩니다.

이때 말하는 의존은 `props` 와 `children` 처럼 데이터가 아닌 렌더링 순서나 타이밍처럼 실행 과정의 개입을 말합니다.

예를 들자면, `A` 컴포넌트가 렌더링될 때 컴포넌트 `B` 의 내부 상태를 수정하거나, `B` 컴포넌트가 먼저 렌더링되어야 `A` 가 정상 작동하는 상황을 말합니다.

</br>
</br>

### 엄격 모드(Strick Mode)로 순수하지 않은 연산을 찾아내기

React에서는 렌더링하는 동안 읽을 수 있는 세 가지 종류의 입력 요소 `Props`, `State`, `Context` 가 있습니다.

이러한 입력 요소는 항상 읽기전용으로 취급해야 합니다.

</br>

사용자의 입력에 따라 무언가를 변경하려는 경우, 변수 값을 직접 수정하는 대신 `State` 를 설정(`set`)하여 컴포넌트가 렌더링되는 동안엔 기존 변수나 객체를 변경해선 안됩니다.

</br>

React는 개발 중에 각 컴포넌트이 함수를 두 번 호출하는 엄격 모드를 제공합니다.

컴포넌트 함수를 두 번 호출함으로써, 엄격 모드는 이러한 규칙을 위반하는 컴포넌트를 찾는데 도움을 줍니다.

순수 함수는 오직 계산만 수행하므로 두 번 호출되더라도 아무것도 변하지 않습니다.

</br>

엄격 모드는 프로덕션에 영향을 주지 않기 때문에 사용자의 앱 속도가 느려지지 않습니다.

엄격 모드를 적용하려면 최상단 컴포넌트를 `<React.StrictMode>` 로 감싸면 됩니다.

몇몇 프레임워크에는 기본적으로 설정되어 있습니다.

</br>
</br>

### 지역 변경 - 컴포넌트의 작은 비밀

지금까지 예시에서의 문제는 컴포넌트가 기존 변수를 렌더링 중에 변경했다는 것입니다.

순수 함수는 함수 스코프 밖의 변수나 호출 전에 생성된 객체를 변경하지 않습니다.

그러나, 렌더링하는 동안 방금 생성한 변수와 객체를 변경하는 것은 전혀 문제가 없습니다.

</br>

다음 예시는 `[]` 배열을 만들고, `cups` 변수에 할당하고, 컵 한 묶음을 `push` 합니다.

```tsx
// App.js
function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaGathering() {
  const cups = [];
  for (let i = 1; i <= 12; i++) {
    cups.push(<Cup key={i} guest={i} />);
  }
  return cups;
}
```

지금까지 예시처럼 `cups` 변수나 `[]` 배열이 `TeaGathering` 의 바깥에서 생성되었다면 문제가 발생합니다.

배열에 요소들을 `push` 하면 이미 존재하던 객체가 직접 변경되기 때문입니다.

</br>

하지만 위 예시에서는 동일한 렌더링 과정 중에 `TeaGathering` 컴포넌트 내부에서 변수와 배열이 생성되었기 때문에 괜챃습니다.

`TeaGathering` 컴포넌트 외부에 있는 코드들은 이런 일이 생겼는지도 모릅니다.

이를 **지역 변경**이라 합니다.

</br>
</br>

### 사이드 이펙트를 일으킬 수 있는 지점

함수형 프로그래밍은 순수성에 크게 의존하지만, 결국 어느 시점에 어디선가 무언가는 바뀌어야 합니다.

화면을 업데이트하고, 애니메이션을 시작하고, 데이터를 변경하는 이러한 변화들을 **사이드 이펙트**라고 합니다.

렌더링 중에 발생하는 것이 아니라 사이드에서 발생하는 현상입니다.

렌더링은 컴포넌트 함수를 실행하여 현재의 데이터 `Props`, `State`를 기반으로 JSX를 반환하는 순수 계산 과정을 말합니다.

</br>

React에서 사이드 이펙트는 보통 이벤트 핸들러 내부에 위치합니다.

이벤트 핸들러는 React가 일부 작업을 수행할 때 반응하는 함수를 말합니다.

이벤트 핸들러가 컴포넌트 내부에 정의되었다 하더라고 렌더링 중에는 실행되지 않습니다.

</br>

**“그래서 이벤트 핸들러는 순수할 필요가 없습니다.”**

</br>

다른 옵션을 모두 사용했음에도 사이드 이펙트를 처리할 적합한 이벤트 핸들러를 찾지 못했다면, 컴포넌트에서 `useEffect` 를 호출해 반환된 JSX에 해당 사이드 이펙트를 연결할 수 있습니다.

이렇게 하면 React가 렌더링을 마치고 사이드 이펙트가 허용됨 시점에 그것을 실행하도록합니다.

그러나 이 방식은 최후의 수단이 되어야 합니다.

</br>

가능하면 렌더링만으로 로직을 표현해야합니다.

즉, 데이터를 변수에 담아 동기적으로 즉시 처리하는게 좋습니다.

</br>
</br>

### React는 왜 순수성을 신경쓸까요?

컴포넌트는 다른 환경에서도 실행될 수 있습니다.

- 예를 들면 서버에서처럼 동일한 입력에 대해 동일한 결과를 반환하기 때문에 하나의 컴포넌트는 많은 사용자 요청을 처리할 수 있습니다.
- 입력이 변경되지 않은 컴포넌트들은 렌더링을 건너뛰어 성능을 향상시킬 수 있습니다.
순수 함수는 항상 동일한 결과를 반환하므로 캐싱하기에 안전합니다.
- 깊은 컴포넌트 트리를 렌더링하는 도중에 일부 데이터가 변경되는 경우, React는 무의미해진 렌더링을 끝내는 데 시간을 낭비하지 않고 렌더링을 아예 다시 시작할 수 있습니다.
순수성은 언제든지 연산을 중단하는 것을 안전하게 합니다.

</br>

우리가 구축하고 있는 모든 새로운 React 기능은 순수성을 활용합니다.

데이터 가져오기에서부터 애니메이션, 성능에 이르기까지 컴포넌트를 순수하게 유지하면 React 패러다임의 힘이 발휘됩니다.

</br>