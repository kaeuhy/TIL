## 덱 - Deque(Double-ended Queue)

덱(Double-ended Queue)은 스택과 큐의 기능을 모두 합친 하이브리드 자료구조입니다.

데이터의 추가와 제거가 양쪽 끝(front, rear)에서 모두 가능합니다.

</br>

> 덱은 왜 사용하는가?
> 

양쪽 끝에서 유연하게 접근해야 하는 복잡한 문제에 사용됩니다.

- **슬라이딩 윈도우 최댓값/최솟값:** 배열의 특정 길이(k)의 부분 배열(윈도우)을 이동시키면서 각 윈도우의 최댓값을 찾는 문제. 덱을 사용하면 O(n)에 해결 가능합니다. 윈도우가 한 칸 이동할 때, 불필요한 값은 앞에서 제거(`removeFront`)하고 새로운 값은 뒤에서 추가(`addRear`)하면서 덱 내부의 값을 정렬된 상태로 유지할 수 있습니다.
- **작업 훔치기 (Work Stealing):** 멀티코어 환경에서, 한 코어의 작업 큐가 비었을 때 다른 바쁜 코어의 작업 큐에서 작업을 '훔쳐'와서 처리하는 스케줄링 기법입니다. 이때 각 코어는 자신의 작업을 위해 덱의 한쪽 끝을 사용하고(스택처럼), 다른 코어는 훔쳐가기 위해 반대쪽 끝을 사용(큐처럼)하여 충돌을 최소화합니다.

</br>

> 주요 연산
> 
- **addFront(item):** 덱의 앞에 데이터를 추가합니다.
- **addRear(item):** 덱의 뒤에 데이터를 추가합니다.
- **removeFront():** 덱의 앞에서 데이터를 제거하고 반환합니다.
- **removeRear():** 덱의 뒤에서 데이터를 제거하고 반환합니다.
- **peekFront():** 덱의 앞 데이터를 확인합니다.
- **peekRear():** 덱의 뒤 데이터를 확인합니다.

</br>
</br>

### 배열 기반 덱 - Array-based Deque

원형 큐와 유사하게 원형 배열을 사용하여 구현할 수 있습니다.

front와 rear 포인터를 사용하여 양쪽 끝에서의 데이터 추가 및 삭제를 관리합니다.

</br>

> 장점
> 

데이터 접근이 빠르며, 원형 구조를 통해 공간을 효율적으로 사용합니다.

</br>

> 단점
> 

고정된 크기를 가지며, 꽉 찼을 경우 크기 조정이 필요합니다.

</br>
</br>

### 연결 리스트 기반 덱 - Linked List-based Deque

이중 연결 리스트(Doubly Linked List)를 사용하여 덱을 구현하는 것이 가장 효율적입니다.

각 노드가 이전 노드(prev)와 다음 노드(next)를 모두 가리키고 있어, 양쪽 끝에서의 추가 및 삭제 연산이 O(1) 시간 복잡도를 가집니다.

</br>

> 장점
> 
- **최고의 유연성 및 성능:** 동적 크기 조절과 모든 연산의 O(1) 성능을 모두 만족하는 가장 이상적인 구현입니다.

</br>

> 단점
> 
- **가장 큰 메모리 오버헤드:** 각 노드가 `value`, `next`, `prev` 세 가지를 저장해야 하므로 메모리 사용량이 가장 큽니다.
- **구현 복잡도:** 포인터 관리가 가장 복잡하고, 실수할 여지가 많습니다.