### 해시?? 해시브라운?? 해시가 뭘까

해시(Hash)는 임의의 길이를 가진 데이터를 고정된 길이의 데이터로 매핑하는 과정 또는 그 결과물을 말합니다.

데이터의 지문이라고 생각하면 편합니다.

<br/>

> **해시 함수**
> 
- **해시 함수**: 임의의 길이를 갖는 입력 데이터(key)를 받아, 정해진 고정된 길이의 정수로 변환하는 함수입니다.
    - **입력**: 어떤 길이의 데이터든 상관없고, 이 데이터를 키(key)라고 부릅니다.
    - **처리**: 내부적으로 복잡한 수학적 연산을 수행합니다.
    - **출력**: 고정된 길이의 값입니다. 이 값을 해시 값(Hash Value)또는 해시 코드(Hash Code)라고 부릅니다.
    - **목적**: 데이터를 효율적으로 저장하고 검색하기 위한 인덱싱입니다.

```tsx
"Hello World"         ---> [ 해시 함수 ] ---> 0a1b2c3d ( 고정 길이의 해시 값 )
"데이터 구조 스터디"      ---> [ 해시 함수 ] ---> 9f8e7d6c ( 고정 길이의 해시 값 )
```

<br/>
<br/>

### 해시 테이블이란 무엇인가?

해시 테이블은 키(key)와 값(value)을 한 쌍으로 저장하는 자료 구조입니다.

단순히 데이터를 저장하는 배열을 넘어, 해시 함수라는 길잡이를 통해 평균적으로 O(1)이라는 시간 복잡도로 데이터에 접근할 수 있게 해주는 것이 핵심입니다.

<br/>

> **일반적인 배열과 비교**
> 
- 배열: 인덱스를 알면 접근 속도가 O(1)로 매우 빠르지만, 원하는 데이터의 인덱스를 알지 못한다면, 처음부터 끝까지 다 찾아봐야 한다. 접근 속도가 O(n)이다.
- 해시 테이블: 어떤 키(key)가 주어지면, 이 키를 배열의 인덱스로 바로 계산해낼 수 있다.

<br/>

> **핵심 구성 요소**
> 
- 버킷 (Bucket) 또는 슬롯 (Slot): 데이터가 실제로 저장되는 공간으로, 보통 배열로 구현됩니다.
- 해시 함수: 임의의 Key를 입력받아 버킷 배열의 특정 인덱스인 해시 값을 반환합니다.
- Key-Value 쌍: 저장하고자 하는 고유한 식별자인 Key와 그에 대응하는 값인 Value입니다.

<br/>
<br/>

### 해시 충돌 및 해결 전략

해시 충돌은 서로 다른 Key를 해시 함수에 입력했는데, 동일한 해시 값(인덱스)이 반환되는 현상을 말합니다.

버킷의 개수보다 Key의 종류가 훨씬 많기 때문에 필연적으로 발생합니다.

효율적인 해시 테이블은 이 충돌을 얼마나 잘 관리하느냐에 따라 성능이 결정됩니다.
충돌 해결 전략은 크게 두 가지로 나뉩니다.

<br/>

> **체이닝 - Chaining**
> 

체이닝은 충돌이 발생했을 때, 해당 버킷에 데이터를 연결 리스트와 같은 자료구조를 사용해 사슬처럼 줄줄이 연결하는 방식입니다.

분리 연결법이라고도 부릅니다.

<br/>

- **동작 과정 예시**
    - 조건: 해시 테이블 크기 M = 8, 해시 함수 h(k) = k % 8
    - 데이터 삽입 순서: 5, 13, 21
1. 데이터가 5인 값을 해시 함수를 통해 5번 버킷에 저장합니다.
2. 데이터가 13인 값을 해시 함수를 통해 5번 버킷에 저장합니다.
3. 이때, 충돌이 발생할텐데, 기존에 있던 5 뒤에 13을 연결 리스트로 연결합니다.
**buckets[5] -> [5] -> [13]**
4. 데이터가 21인 값도 5번 버킷에 저장하여 충돌을 발생시킵니다.
**buckets[5] -> [5] -> [13] -> [21]**

<br/>

- **체이닝의 장점과 단점**
    - **장점**
        - 구현이 비교적 간단하고 직관적입니다.
        - 해시 테이블의 버킷 수보다 데이터가 많아져도 문제없이 동작합니다.
        - 데이터가 뭉치는 현상 문제에 영향을 받지 않습니다.
    - **단점**
        - 연결 리스트를 위한 추가적인 메모리 공간이 필요합니다.
        - 특정 버킷에 데이터가 집중되면, 해당 버킷의 연결 리스트를 순차 탐색해야 하므로 시간 복잡도가 커집니다.
        - 데이터가 버킷과 연결 리스트 노드에 흩어져 저장되므로, 캐시 지역성이 좋지 않아 성능이 떨어질 수 있습니다.

<br/>

> **개방 주소법 - Open Addressing**
> 

개방 주소법은 충돌이 발생했을 때, 다른 비어있는 버킷을 찾아 데이터를 저장하는 방식입니다.

모든 데이터는 해시 테이블 배열 내에 직접 저장되며, 추가적인 자료구조를 사용하지 않습니다.

<br/>

- **동작 과정 예시**
    - **선형 탐사**: 충돌이 발생한 버킷 바로 다음 버킷부터 순차적으로 빈 공간을 탐색합니다.
        - **장점**: 구현이 간단하고 캐시 효율성이 좋습니다
        - **단점**: 데이터가 연속된 덩어리로 뭉치게 되어, 이 덩어리가 커질수록 탐색과 삽입 시간이 급격히 늘어납니다.
    - **제곱 탐사**: 충돌 발생 시, 탐사 폭을 1², 2², 3²… 만큼 넓혀가며 빈 공간을 찾습니다.
        - **장점**: 선형 탐사에서 발생한 단점을 크게 완화합니다.
        - **단점**:
            - 초기 해시 값이 같은 Key들은 모두 동일한 탐사 순서를 밟게 되어, 효율이 떨어질 수 있습니다.
            - 테이블 크기 M이 소수가 아니거나 적재율이 높으면, 모든 버킷을 탐사하지 못하고 탐색에 실패할 수 있습니다.
    - **이중 해싱**: 2개의 해시 함수를 사용하여, 첫 번째 해시 함수는 초기 위치를 정하고, 두 번째 해시 함수는 충돌 발생 시 탐사할 이동 폭을 정합니다.
        - **특징**: 두 번째 해시 함수는 0이 아닌 값을 반환해야 하며, 테이블 크기 M과 서로소인 값을 반환하도록 설계하는 것이 좋습니다.
        - **장점**: 데이터를 테이블 전체에 가장 고르게 분포시켜, 다른 개방 주소법보다 성능 저하가 훨씬 적습니다.
        - **단점**: 두 개의 해시 함수를 계산해야 하므로 연산 비용이 다른 방식보다 조금 더 큽니다.

- **개방 주소법의 공통적인 장점과 단점**
    - **장점**:
        - 추가적인 저장공간이 필요 없습니다.
        - 데이터가 배열에 연속적으로 저장되므로 캐시 효율성이 높아 실제 성능이 좋을 수 있습니다.
    - **단점**:
        - 단순히 데이터를 지우면, 그 위치를 거쳐갔던 다른 데이터의 탐색 경로가 끊길 수 있어 데이터 삭제가 복잡합니다.


<br/>
<br/>

### 해시 맵

해시 맵은 키와 같을 하나의 쌍으로 묶어 저장하는 추상적인 자료구조입니다.

해시 테이블과 달리, 개발자에게 put, get 등과 같은 기능 명세인 인터페이스를 제공하여 무엇을 할 수 있는지에 초점을 맞춥니다.

- **해시 테이블과의 개념 비교**
    - **해시 테이블**: 어떻게 데이터를 저장하고 충돌을 해결하는지에 대한 구체적인 구현체입니다.
    - **해시 맵**: 무엇을 할 수 있는지 정의한 설계도 또는 인터페이스입니다.

- **핵심 연산**
    - **put(key, value)**: 키에 값을 연결하여 저장합니다. 키가 이미 존재하면 값을 덮어씁니다.
    - **get(key)**: 키에 연결된 값을 찾아 반환합니다.
    - **remove(key)**: 키와 연결된 값의 쌍을 삭제합니다.
    - **containsKey(key)**: 키의 존재 여부를 확인합니다.
    - **size()**: 저장된 데이터의 개수를 반환합니다.

<br/>

> **Key의 자격 요건**
> 

해시 맵의 키는 아무 객체나 될 수 없으며, 정상적인 동작을 위해 반드시 두 가지 핵심 조건을 만족해야 합니다.

1. **해시 가능성**
    - 객체의 내용을 바탕으로 일관된 해시 코드를 생성할 수 있어야 합니다.
    - 객체의 내용이 같다면, 언제 어디서 호출하든 항상 동일한 해시 코드가 반환되어야 합니다.
    - 이 때문에 내용이 변하지 않는 불변 객체가 Key로 사용하기에 가장 이상적입니다.
2. **동등성 비교 가능성**
    - 해시 코드가 우연히 같은 다른 키와 마주쳤을 때, 내가 찾으려는 키가 맞는지 정확하게 비교할 수 있어야 합니다.

해시 함수는 '어느 버킷으로 갈지' 알려주고, 동등성 비교는 '그 버킷 안의 여러 데이터 중 정확히 내 것이 맞는지' 최종 확인하는 역할을 합니다.

<br/>

- **해시 맵의 장점과 단점**
    - **장점**
        - **압도적인 속도**: 평균적으로 O(1)의 시간 복잡도로 데이터를 읽고 쓸 수 있어 매우 효율적입니다.
        - **직관적인 사용법**: 키를 통해 값을 직관적으로 관리할 수 있어 코드가 간결해집니다.
        - **높은 활용도**: 캐싱, 데이터 인덱싱 등 현대 프로그래밍의 다양한 문제 해결에 널리 사용됩니다.
    - **단점**
        - **메모리 사용량**: 데이터를 저장하기 위해 실제 데이터 외에 해시 테이블(배열)을 위한 추가적인 메모리 공간이 필요합니다.
        - **순서 보장 안 됨**: 일반적인 해시 맵은 데이터가 삽입된 순서를 보장하지 않습니다.
        - **최악의 경우 성능 저하**: 해시 충돌이 매우 심하게 발생할 경우, 성능이 O(N)까지 저하될 수 있습니다.

<br/>